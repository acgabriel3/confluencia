\coqlibrary{confl lambda}{Library }{confl\_lambda}

\begin{coqdoccode}
\coqdocemptyline
\end{coqdoccode}
\section{Locally Nameless Notation}

\begin{coqdoccode}
\coqdocemptyline
\coqdocemptyline
\end{coqdoccode}
A notação de nomes locais é definida de forma a trabalhar com index's ligados à abstrações
para representar variáveis ligadas, e variáveis nomeadas para representar variáveis livres. Dessa
forma podemos ter um conjunto de símbolos nesta notação que não sejam válidos semanticamente. 
Vamos exemplificar: 


Dada a abstração $\lambda.0$ sabemos que o index 0 representa a variável ligada à abstração
que apresentamos. O index 0 neste caso indica que existem 0 passos para em uma aplicação
substituir a variável ligada que o mesmo representa. Estando esse index portanto ligado
diretamente à abstração apresentada, e sendo dessa maneira válido semanticamente. Porém,
sintaticamente o index pode ser um valor iteiro k qualquer. Assim, por exemplo, ao 
fazermos $\lambda.1$, estamos construindo semanticamente uma relação que não possui 
significado válido. Queremos representar variáveis ligadas por meio de index's e neste caso o 
index 1 não está ligado à nenhuma abstração, portanto não representa uma variável ligada
e não é válido para nossa representação.

 Assim podemos definir o conceito de pré-termo como sendo: Todo conjunto de símbolos sintaticamente
válidos, que ainda não temos certeza acerca da validade semântica. Além disso, um pré-termo pode
aparecer entre os termos anterior e resultante das operações realizadas no cálculo lambda.
Matematicamente os pré-termos são definidos de acordo com a seguinte gramática: \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Inductive} \coqdocvar{pterm} : \coqdockw{Set} :=\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqdocvar{pterm\_bvar} : \coqdocvar{nat} \ensuremath{\rightarrow} \coqdocvar{pterm}\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqdocvar{pterm\_fvar} : \coqdocvar{var} \ensuremath{\rightarrow} \coqdocvar{pterm}\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqdocvar{pterm\_app}  : \coqdocvar{pterm} \ensuremath{\rightarrow} \coqdocvar{pterm} \ensuremath{\rightarrow} \coqdocvar{pterm}\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqdocvar{pterm\_abs}  : \coqdocvar{pterm} \ensuremath{\rightarrow} \coqdocvar{pterm}\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqdocvar{pterm\_labs}  : \coqdocvar{pterm} \ensuremath{\rightarrow} \coqdocvar{pterm}.\coqdoceol
\coqdocemptyline
\coqdocemptyline
\end{coqdoccode}
\subsection{Operações com os pré-termos}



 Para trabalhar com a validade dos termos, e tornar a mesma decidível, precisamos definir
algumas operações que permitirão à máquina fazer as devidas buscas e comparações. Estas operações
serão definidas mais abaixo.

 A definição da operação ``variable opening'', ou seja, abertura de variáveis é dada abaixo:\begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Fixpoint} \coqdocvar{open\_rec} (\coqdocvar{k} : \coqdocvar{nat}) (\coqdocvar{u} : \coqdocvar{pterm}) (\coqdocvar{t} : \coqdocvar{pterm}) : \coqdocvar{pterm} :=\coqdoceol
\coqdocindent{1.00em}
\coqdockw{match} \coqdocvar{t} \coqdockw{with}\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqdocvar{pterm\_bvar} \coqdocvar{i}    \ensuremath{\Rightarrow} \coqdockw{if} \coqdocvar{k} === \coqdocvar{i} \coqdockw{then} \coqdocvar{u} \coqdockw{else} (\coqdocvar{pterm\_bvar} \coqdocvar{i})\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqdocvar{pterm\_fvar} \coqdocvar{x}    \ensuremath{\Rightarrow} \coqdocvar{pterm\_fvar} \coqdocvar{x}\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqdocvar{pterm\_app} \coqdocvar{t1} \coqdocvar{t2} \ensuremath{\Rightarrow} \coqdocvar{pterm\_app} (\coqdocvar{open\_rec} \coqdocvar{k} \coqdocvar{u} \coqdocvar{t1}) (\coqdocvar{open\_rec} \coqdocvar{k} \coqdocvar{u} \coqdocvar{t2})\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqdocvar{pterm\_abs} \coqdocvar{t1}    \ensuremath{\Rightarrow} \coqdocvar{pterm\_abs} (\coqdocvar{open\_rec} (\coqdocvar{S} \coqdocvar{k}) \coqdocvar{u} \coqdocvar{t1})\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqdocvar{pterm\_labs} \coqdocvar{t1}    \ensuremath{\Rightarrow} \coqdocvar{pterm\_labs} (\coqdocvar{open\_rec} (\coqdocvar{S} \coqdocvar{k}) \coqdocvar{u} \coqdocvar{t1})\coqdoceol
\coqdocindent{1.00em}
\coqdockw{end}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
Esta operação é responsável por substituir todos os índices ``k'', por uma variável com
nome qualquer. Por exemplo, digamos que tenhamos o pré-termo $\lambda.0 y$, assim, ao aplicar
a operação $ {0 ~> x} \lambda.0 y$ teremos o seguinte resultado: $\lambda.x y$.

 Com isso, a operação de abertura recursiva apenas para index's 0 é definida especialmente 
como ``open'', onde u é o nome de uma variável qualquer e t é um pré-termo, logo abaixo:\begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Definition} \coqdocvar{open} \coqdocvar{t} \coqdocvar{u} := \coqdocvar{open\_rec} 0 \coqdocvar{u} \coqdocvar{t}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
Esta definição será extremamente útil nas provas mais abaixo, devido à maior facilidade com relação
à trabalhar com qualquer index k, e para garantir que estamos trabalhando com termos válidos.

 De qualquer forma, a operação como explicada mais acima, onde k é o index de De Bruijin,
u o nome de uma variável qualquer e t o pré-termo que será aberto recursivamente no index k é 
definida como se segue:\begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Notation} "\{ k \~{}> u \} t" := (\coqdocvar{open\_rec} \coqdocvar{k} \coqdocvar{u} \coqdocvar{t}) (\coqdoctac{at} \coqdockw{level} 67).\coqdoceol
\coqdocemptyline
\coqdocemptyline
\end{coqdoccode}
Notação para representar a abertura de um termo, substituindo as variáveis ligadas
por qualquer tipo de pré-termo.\begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Notation} "t \^{}\^{} u" := (\coqdocvar{open} \coqdocvar{t} \coqdocvar{u}) (\coqdoctac{at} \coqdockw{level} 67).\coqdoceol
\coqdocemptyline
\end{coqdoccode}
Notação para representar abertura de um pré-termo utilizando uma variável livre
x:\begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Notation} "t \^{} x" := (\coqdocvar{open} \coqdocvar{t} (\coqdocvar{pterm\_fvar} \coqdocvar{x})).\coqdoceol
\coqdocemptyline
\coqdocemptyline
\end{coqdoccode}
A definição de termo é dada logo abaixo:\begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Inductive} \coqdocvar{term} : \coqdocvar{pterm} \ensuremath{\rightarrow} \coqdockw{Prop} :=\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqdocvar{term\_var} : \coqdockw{\ensuremath{\forall}} \coqdocvar{x},\coqdoceol
\coqdocindent{3.00em}
\coqdocvar{term} (\coqdocvar{pterm\_fvar} \coqdocvar{x})\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqdocvar{term\_app} : \coqdockw{\ensuremath{\forall}} \coqdocvar{t1} \coqdocvar{t2},\coqdoceol
\coqdocindent{3.00em}
\coqdocvar{term} \coqdocvar{t1} \ensuremath{\rightarrow} \coqdoceol
\coqdocindent{3.00em}
\coqdocvar{term} \coqdocvar{t2} \ensuremath{\rightarrow} \coqdoceol
\coqdocindent{3.00em}
\coqdocvar{term} (\coqdocvar{pterm\_app} \coqdocvar{t1} \coqdocvar{t2})\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqdocvar{term\_abs} : \coqdockw{\ensuremath{\forall}} \coqdocvar{L} \coqdocvar{t1},\coqdoceol
\coqdocindent{3.00em}
(\coqdockw{\ensuremath{\forall}} \coqdocvar{x}, \coqdocvar{x} \symbol{92}\coqdocvar{notin} \coqdocvar{L} \ensuremath{\rightarrow} \coqdocvar{term} (\coqdocvar{t1} \^{} \coqdocvar{x})) \ensuremath{\rightarrow}\coqdoceol
\coqdocindent{3.00em}
\coqdocvar{term} (\coqdocvar{pterm\_abs} \coqdocvar{t1}).\coqdoceol
\coqdocemptyline
\end{coqdoccode}
Um termo é válido na notação de nomes locais, quando este termo é um termo fechado. 
Para ser um termo fechado, seguimos uma definição recursiva, onde toda variável livre, e portanto
nomeada é fechada, toda aplicação é fechada, se seus dois termos internos são fechados, e toda
abstração é fechada, se todos os termos que fazem parte da mesma também são fechados. Veja que esta é
exatamente a definição que temos logo acima. Podemos deixar o entendimento mais fácil com a seguinte
definição: Um termo é um pré-termo sem nenhuma variável ligada inválida, ou seja, nenhum index não ligado
à uma abstração de alguma maneira.

 Dessa forma também é interessante definir o conceito de corpo, como sendo todo pré-termo
que após uma abertura no index 0, por uma variável nomeada livre x, torna-se um termo fechado.
A definição está logo abaixo:\begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Definition} \coqdocvar{body} \coqdocvar{t} :=\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{\ensuremath{\exists}} \coqdocvar{L}, \coqdockw{\ensuremath{\forall}} \coqdocvar{x}, \coqdocvar{x} \symbol{92}\coqdocvar{notin} \coqdocvar{L} \ensuremath{\rightarrow} \coqdocvar{term} (\coqdocvar{t} \^{} \coqdocvar{x}).\coqdoceol
\coqdocemptyline
\end{coqdoccode}
Perceba que a definição de body foi utilizada na definição recursiva de termo, para
representar as abtrações válidas semanticamente, segundo os conceitos aqui já apresentados.\begin{coqdoccode}
\coqdocemptyline
\coqdocemptyline
\end{coqdoccode}
Para realizar a prova da confluência é necessária a definição de um termo marcado. Um
termo marcado contém exatamente as mesmas propriedades de um termo, exceto que, pode possuir
abstrações marcadas. Abstrações marcadas são aquelas que estão postas em uma aplicação válida,
aonde pode ser aplicada uma B-redução. Abstrações que não fazem parte de uma aplicação, não podem ser 
abstrações marcadas. Podemos ver essa definição em termos recursivos logo abaixo:\begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Inductive} \coqdocvar{lterm} : \coqdocvar{pterm} \ensuremath{\rightarrow} \coqdockw{Prop} :=\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqdocvar{lterm\_var} : \coqdockw{\ensuremath{\forall}} \coqdocvar{x},\coqdoceol
\coqdocindent{3.00em}
\coqdocvar{lterm} (\coqdocvar{pterm\_fvar} \coqdocvar{x})\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqdocvar{lterm\_app} : \coqdockw{\ensuremath{\forall}} \coqdocvar{t1} \coqdocvar{t2},\coqdoceol
\coqdocindent{3.00em}
\coqdocvar{lterm} \coqdocvar{t1} \ensuremath{\rightarrow} \coqdoceol
\coqdocindent{3.00em}
\coqdocvar{lterm} \coqdocvar{t2} \ensuremath{\rightarrow} \coqdoceol
\coqdocindent{3.00em}
\coqdocvar{lterm} (\coqdocvar{pterm\_app} \coqdocvar{t1} \coqdocvar{t2})\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqdocvar{lterm\_abs} : \coqdockw{\ensuremath{\forall}} \coqdocvar{L} \coqdocvar{t1},\coqdoceol
\coqdocindent{3.00em}
(\coqdockw{\ensuremath{\forall}} \coqdocvar{x}, \coqdocvar{x} \symbol{92}\coqdocvar{notin} \coqdocvar{L} \ensuremath{\rightarrow} \coqdocvar{lterm} (\coqdocvar{t1} \^{} \coqdocvar{x})) \ensuremath{\rightarrow}\coqdoceol
\coqdocindent{3.00em}
\coqdocvar{lterm} (\coqdocvar{pterm\_abs} \coqdocvar{t1})\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqdocvar{lterm\_labs} : \coqdockw{\ensuremath{\forall}} \coqdocvar{L} \coqdocvar{t1} \coqdocvar{t2},\coqdoceol
\coqdocindent{3.00em}
(\coqdockw{\ensuremath{\forall}} \coqdocvar{x}, \coqdocvar{x} \symbol{92}\coqdocvar{notin} \coqdocvar{L} \ensuremath{\rightarrow} \coqdocvar{lterm} (\coqdocvar{t1} \^{} \coqdocvar{x})) \ensuremath{\rightarrow}\coqdoceol
\coqdocindent{3.00em}
\coqdocvar{lterm} \coqdocvar{t2} \ensuremath{\rightarrow}\coqdoceol
\coqdocindent{3.00em}
\coqdocvar{lterm} (\coqdocvar{pterm\_app} (\coqdocvar{pterm\_labs} \coqdocvar{t1}) \coqdocvar{t2}).\coqdoceol
\coqdocemptyline
\end{coqdoccode}
Assim, também é possível definir o corpo marcado, como sendo o pré-termo que possui dentro de 
si uma abstração marcada, aonde após uma abertura recursiva do index 0 com uma variável nomeada 
livre qualquer x, torna-se um termo marcado:\begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Definition} \coqdocvar{lbody} \coqdocvar{t} :=\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{\ensuremath{\exists}} \coqdocvar{L}, \coqdockw{\ensuremath{\forall}} \coqdocvar{x}, \coqdocvar{x} \symbol{92}\coqdocvar{notin} \coqdocvar{L} \ensuremath{\rightarrow} \coqdocvar{lterm} (\coqdocvar{t} \^{} \coqdocvar{x}).\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Hint Constructors} \coqdocvar{lterm} \coqdocvar{term}.\coqdoceol
\coqdocemptyline
\coqdocemptyline
\coqdocemptyline
\end{coqdoccode}
\section{Definições técnicas e explanação teórica}



 Para auxiliar nas provas são necessárias algumas definições no assistente de provas. Existem casos em que é melhor
seguir uma prova por indução na estrutura, nestes casos, o assistente consegue lidar bem com seus pŕoprios comandos. No entanto,
quando precisamos trabalhar com provas no tamanho dos termos, muitas vezes são necessárias definições para contar o tamanho do
tipo que estamos lidando. E posteriormente, essas definições são utilizadas para definir induções no tamanho específicas para o 
domínio em que estamos trabalhando. Não vamos apresentar estas definições neste trabalho, por serem muito técnicas e poderem
ser facilmente encontradas em outros trabalhos da literatura (possivelmente citar trabalhos aqui). 

 No trabalho de \symbol{92}cite\{Chargerout\} (concertar citação) e na notação de nomes locais é necessária a definição de operações de
abertura e fechamento dos termos. As operações de abertura e fechamento manipulam os index's e nomes, e têm como objetivo controlar
e tornar possível a decisão de se um termo é ou não fechado, ou seja, possui uma sintaxe válida. Não iremos mostrar essas definições
neste trabalho, pois as mesmas podem ser encontradas no próprio trabalho de \symbol{92}cite\{Chargerout\} (concertar citação), mas estas definições
foram utilizadas e exploradas neste trabalho. \begin{coqdoccode}
\coqdocemptyline
\coqdocemptyline
\end{coqdoccode}
Existe outra maneira de saber se um pré-termo é localmente fechado. Além do uso do open, 
podemos definir um tipo recursivo chamado ``lc\_at''. A ideia é trabalhar com os index's de modo
a verificar se todos possuem ligação com uma abstrção, e caso sim, o termo será um termo fechado.
Ser um termo fechado, como já dito, significa ser um termo válido para o $\lambda$-cálculo. A comparação
realizada para os index's refere-se a se estes são menores do que um valor k, ligado ao número de 
abstrações. 

 Para um termo ser realmente localmente fechado segundo essa definição, ele precisa ser lc\_at 0, 
ou seja, ele não pode conter nenhum index sem ligações válidas com abstrações. Entendemos melhor essa
propriedade ao analisar a definição recursiva do lc\_at. Toda variável livre é localmente fechada. A medida
que um termo será localmente fechado para uma aplicação, se seus dois subtermos também foram localmente fechados.
E para uma abstração, o será se o termo envolvido pela abstração for localmente fechado para k + 1.
Para a variável ligada, portanto, o termo será localmente fechado caso o index i que representa a variável
ligada seja menor do que k. Veja a definição abaixo: \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Fixpoint} \coqdocvar{lc\_at} (\coqdocvar{k}:\coqdocvar{nat}) (\coqdocvar{t}:\coqdocvar{pterm}) : \coqdockw{Prop} :=\coqdoceol
\coqdocindent{1.00em}
\coqdockw{match} \coqdocvar{t} \coqdockw{with}\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqdocvar{pterm\_bvar} \coqdocvar{i}    \ensuremath{\Rightarrow} \coqdocvar{i} < \coqdocvar{k}\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqdocvar{pterm\_fvar} \coqdocvar{x}    \ensuremath{\Rightarrow} \coqdocvar{True}\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqdocvar{pterm\_app} \coqdocvar{t1} \coqdocvar{t2} \ensuremath{\Rightarrow} \coqdocvar{lc\_at} \coqdocvar{k} \coqdocvar{t1} \ensuremath{\land} \coqdocvar{lc\_at} \coqdocvar{k} \coqdocvar{t2}\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqdocvar{pterm\_abs} \coqdocvar{t1}    \ensuremath{\Rightarrow} \coqdocvar{lc\_at} (\coqdocvar{S} \coqdocvar{k}) \coqdocvar{t1}\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqdocvar{pterm\_labs} \coqdocvar{t1}    \ensuremath{\Rightarrow} \coqdocvar{lc\_at} (\coqdocvar{S} \coqdocvar{k}) \coqdocvar{t1}\coqdoceol
\coqdocindent{1.00em}
\coqdockw{end}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
O lc\_at pode ser usado em diversos teoremas matemáticos relacionados tanto ao open, quanto
à definição de termos. Esses teoremas podem facilitar provas com nível de abstração mais elevado
na teoria do cálculo lambda, permitindo a equivalência entre diferentes tipos e propriedades.

\section{Propriedades importantes do cálculo lambda e suas provas}

\begin{coqdoccode}
\coqdocemptyline
\coqdocemptyline
\end{coqdoccode}
Precisamos definir e provar diversas propriedades do cálculo lambda que irão ser muito úteis
para a construção das provas de confluência que estamos construindo. Nesse sentido, muitas das propriedades
que poderiam parecer simples de provar, no assistente de provas essa tarefa torna-se muitas vezes muito
mais complicada. 

 Uma das propriedades mais interessantes da notação sem nomes locais que empregamos é que ela não necessita da alfa conversão,
facilitando e tornando decidíveis para a máquina diversas operações que antes não o seriam. Podemos
provar essa propriedade por meio da definição de lc\_at, como se segue no lema abaixo, onde sua prova no coq segue de maneira trivial. Neste
lema mostramos que se dois nomes são utilizados como variáveis livres em uma estrutura análoga, então eles são localmente fechados em um nível m.  \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdocvar{lc\_at\_open\_rec\_rename}: \coqdockw{\ensuremath{\forall}} \coqdocvar{t} \coqdocvar{x} \coqdocvar{y} \coqdocvar{m} \coqdocvar{n}, \coqdocvar{lc\_at} \coqdocvar{m} (\coqdocvar{open\_rec} \coqdocvar{n} (\coqdocvar{pterm\_fvar} \coqdocvar{x}) \coqdocvar{t}) \ensuremath{\rightarrow} \coqdocvar{lc\_at} \coqdocvar{m} (\coqdocvar{open\_rec} \coqdocvar{n} (\coqdocvar{pterm\_fvar} \coqdocvar{y}) \coqdocvar{t}).\coqdoceol
\coqdocemptyline
\coqdocemptyline
\end{coqdoccode}
Outra propriedade importante é o fato de que se um pré-termo é localmente fechado no nível n, então ele também é localmente fechado
para qualquer nível maior do que n. Esta propriedade pode ser provada segundo a definição do lema abaixo, e sua prova no coq é trivial.\begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdocvar{lc\_at\_weaken}: \coqdockw{\ensuremath{\forall}} \coqdocvar{t} \coqdocvar{n} \coqdocvar{m}, \coqdocvar{n} \ensuremath{\le} \coqdocvar{m} \ensuremath{\rightarrow} \coqdocvar{lc\_at} \coqdocvar{n} \coqdocvar{t} \ensuremath{\rightarrow} \coqdocvar{lc\_at} \coqdocvar{m} \coqdocvar{t}.\coqdoceol
\coqdocemptyline
\coqdocemptyline
\end{coqdoccode}
É importante demonstrar também a relação de sucessor com relação à termos localmente fechados e abertos com open. Nesse caso,
se um pré-termo é localmente fechado em m e é aberto em m com a variável livre qualquer x, então ele continuará localmente fechado para
m + 1. A prova desta propriedade é um pouco mais complexa, mas pode ser realizada com um pouco de esforço no coq.\begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdocvar{lc\_at\_open}: \coqdockw{\ensuremath{\forall}} \coqdocvar{t} \coqdocvar{m} \coqdocvar{x}, \coqdocvar{lc\_at} \coqdocvar{m} (\{\coqdocvar{m} \~{}> \coqdocvar{pterm\_fvar} \coqdocvar{x}\} \coqdocvar{t}) \ensuremath{\leftrightarrow} \coqdocvar{lc\_at} (\coqdocvar{S} \coqdocvar{m}) \coqdocvar{t}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
Assim, também somos capazes de provar uma das propriedades que já havíamos citado acima, a de que um termo é um pré-termo
fechado para o index 0. Essa conversão pode permitir trabalhar a definição de lc\_at ao invés de term, quando essa for mais conveniente. A
prova para esse teorema é simples, mas necessita da prova do lema lc\_at\_open para ser concluída.\begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdocvar{term\_to\_lc\_at} : \coqdockw{\ensuremath{\forall}} \coqdocvar{t}, \coqdocvar{term} \coqdocvar{t} \ensuremath{\rightarrow} \coqdocvar{lc\_at} 0 \coqdocvar{t}.\coqdoceol
\coqdocemptyline
\coqdocemptyline
\end{coqdoccode}
O mesmo segue para o termo marcado, por definição. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdocvar{lterm\_to\_lc\_at} : \coqdockw{\ensuremath{\forall}} \coqdocvar{t}, \coqdocvar{lterm} \coqdocvar{t} \ensuremath{\rightarrow} \coqdocvar{lc\_at} 0 \coqdocvar{t}.\coqdoceol
\coqdocemptyline
\coqdocemptyline
\coqdocemptyline
\coqdocemptyline
\end{coqdoccode}
Muitas vezes pode ser importante considerar se um pré-termo possui um index livre. Isto para checar
por exemplo, se há a possibilidade de uma redução de uma abstração. Isso pode ser realizado por meio da definição abaixo:\begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Fixpoint} \coqdocvar{has\_free\_index} (\coqdocvar{k}:\coqdocvar{nat}) (\coqdocvar{t}:\coqdocvar{pterm}) : \coqdockw{Prop} :=\coqdoceol
\coqdocindent{1.00em}
\coqdockw{match} \coqdocvar{t} \coqdockw{with}\coqdoceol
\coqdocindent{2.00em}
\ensuremath{|} \coqdocvar{pterm\_bvar} \coqdocvar{n} \ensuremath{\Rightarrow} \coqdockw{if} (\coqdocvar{k} === \coqdocvar{n}) \coqdockw{then} \coqdocvar{True} \coqdockw{else} \coqdocvar{False}\coqdoceol
\coqdocindent{2.00em}
\ensuremath{|} \coqdocvar{pterm\_fvar} \coqdocvar{x} \ensuremath{\Rightarrow} \coqdocvar{False}\coqdoceol
\coqdocindent{2.00em}
\ensuremath{|} \coqdocvar{pterm\_app} \coqdocvar{t1} \coqdocvar{t2} \ensuremath{\Rightarrow} (\coqdocvar{has\_free\_index} \coqdocvar{k} \coqdocvar{t1}) \ensuremath{\lor} (\coqdocvar{has\_free\_index} \coqdocvar{k} \coqdocvar{t2})\coqdoceol
\coqdocindent{2.00em}
\ensuremath{|} \coqdocvar{pterm\_abs} \coqdocvar{t1} \ensuremath{\Rightarrow} \coqdocvar{has\_free\_index} (\coqdocvar{S} \coqdocvar{k}) \coqdocvar{t1}\coqdoceol
\coqdocindent{2.00em}
\ensuremath{|} \coqdocvar{pterm\_labs} \coqdocvar{t1} \ensuremath{\Rightarrow} \coqdocvar{has\_free\_index} (\coqdocvar{S} \coqdocvar{k}) \coqdocvar{t1}\coqdoceol
\coqdocindent{1.00em}
\coqdockw{end}.\coqdoceol
\coqdocemptyline
\coqdocemptyline
\end{coqdoccode}
Respeitando a questão da alfa conversão, podemos demonstrar que se um pre-termo recebe uma substituição pela variável livre x, 
 então ao receber de uma outra variável qualquer y uma substituição, este pré-termo continuaria sendo um termo.\begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdocvar{term\_rename}: \coqdockw{\ensuremath{\forall}} \coqdocvar{t} \coqdocvar{x} \coqdocvar{y}, \coqdocvar{term} (\coqdocvar{t} \^{} \coqdocvar{x}) \ensuremath{\rightarrow} \coqdocvar{term} (\coqdocvar{t} \^{} \coqdocvar{y}).\coqdoceol
\coqdocemptyline
\coqdocemptyline
\coqdocemptyline
\coqdocemptyline
\coqdocemptyline
\coqdocemptyline
\end{coqdoccode}
também precisamos provar que, para um termo qualquer, qualquer substituição não tem efeito. Essa propriedade pode 
ser muito valiosa para algumas provas, principalmente a prova do lema da substituição, e é definida como no lema abaixo:\begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdocvar{subst\_term}: \coqdockw{\ensuremath{\forall}} \coqdocvar{t} \coqdocvar{u} \coqdocvar{n}, \coqdocvar{term} \coqdocvar{t} \ensuremath{\rightarrow} \{\coqdocvar{n} \~{}> \coqdocvar{u}\} \coqdocvar{t} = \coqdocvar{t}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
Por definição o mesmo também vale para um termo marcado: \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdocvar{subst\_lterm}: \coqdockw{\ensuremath{\forall}} \coqdocvar{t} \coqdocvar{u} \coqdocvar{n}, \coqdocvar{lterm} \coqdocvar{t} \ensuremath{\rightarrow} \{\coqdocvar{n} \~{}> \coqdocvar{u}\} \coqdocvar{t} = \coqdocvar{t}.\coqdoceol
\coqdocemptyline
\coqdocemptyline
\coqdocemptyline
\end{coqdoccode}
O lema da substituição é muito importante quando estamos realizando algumas operações e provas no cálculo lambda. Abaixo temos
a sua definição como tentamos o provar, no entanto, ainda sem sucesso. O lema da substituição afirma que, realizar uma substituição A
após já ter realizado uma substituição B prévia, é equivalente à realizar a substituição posterior A primeiro, e a substituição posterior B
depois, mas é necessário realizar uma substituição dentro do termo que será a substituição na substituição A pela mesma substituição
B. Vamos exemplificar na notação que estamos utilizando: $ {n ~> u}{j ~> a} t = {j ~> a} {n ~> {j ~> a} u} t $. Veja que algumas propriedades
devem ser levadas em consideração: i e j devem ser index's distintos, para não haver dessa forma inconformidades. Sugerimos a realização 
de provas em estrutura de árvores de prova (citação?), para que essa situação seja melhor compreendida. A definição do lema, para a construção de 
sua prova em assistente de provas está logo abaixo: \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdocvar{subst\_lemma\_lterms}: \coqdockw{\ensuremath{\forall}} (\coqdocvar{t1} \coqdocvar{t2} \coqdocvar{t3}: \coqdocvar{pterm}) (\coqdocvar{i} \coqdocvar{j}:\coqdocvar{nat}), \coqdocvar{lterm} \coqdocvar{t2} \ensuremath{\rightarrow} \coqdocvar{lterm} \coqdocvar{t3} \ensuremath{\rightarrow} \coqdocvar{i} \ensuremath{\not=} \coqdocvar{j} \ensuremath{\rightarrow} \{\coqdocvar{j} \~{}> \coqdocvar{t3}\} (\{\coqdocvar{i} \~{}> \coqdocvar{t2}\} \coqdocvar{t1}) = \{\coqdocvar{i} \~{}> \coqdocvar{t2}\} (\{\coqdocvar{j} \~{}> \coqdocvar{t3}\} \coqdocvar{t1}).\coqdoceol
\coqdocemptyline
\coqdocemptyline
\coqdocemptyline
\coqdocemptyline
\end{coqdoccode}
\section{Definição de beta redução}



 A operação da beta redução é muito importante para o cálculo lambda. Uma beta redução consiste na operação de reduzir uma aplicação
com uma abstração à esquerda, à substituição da abstração em todos os lugares em que o index local ocorrer no termo envolvido pela abstração
em questão. No assistente de provas, para definir essa operação, precisamos seguir alguns passos, devido à quantidade de possíveis eventos quando
da aplicação da operação. Estes passos se encontram logo abaixo.

 Inicialmente criamos a propriedade de relação, advinda da teoria dos conjuntos. Uma relação é um binômio (a,b), onde a e b pertencem 
à um mesmo conjunto de tipos, como por exemplo, o conjunto dos números reais. No assistente de provas isso pode ser feito como abaixo: Se
um determinado tipo A, implica em um determinado tipo A, então temos uma propriedade.\begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Definition} \coqdocvar{Rel} (\coqdocvar{A}:\coqdockw{Type}) := \coqdocvar{A} \ensuremath{\rightarrow} \coqdocvar{A} \ensuremath{\rightarrow} \coqdockw{Prop}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
\subsection{Definição de redex}



 Para trabalhar com a beta redução é muito importante trabalhar com o conceito de redex. Um redex nada mais é do que uma aplicação
que possui uma abstração marcada ou não à sua esquerda. Dessa forma precisamos definir o feixo contextual transitivo, ou seja, precisamos ajudar
a máquina a entender quando existem ou não redex's em um termo. Um feixo contextutal transitivo define uma relação direta entre dois termos,
estes termos seguem algumas restrições. Podemos dizer que, estes termos são o termo anterior à uma beta redução, e o termo posterior à aplicação
de uma beta redução em um redex específico de um termo e estes dois termos participam portanto de uma relação. Como a definição de termo 
é recursiva, e uma aplicação ocorre entre dois termos, então precisamos deixar claro para a máquina que, primeiro as beta reduções que ocorrerem
tanto à esquerda, quanto à direita, em uma aplicação relacionam o termo anterior, ao termo resultante. Além disso, também precisamos relacionar
os termos resultantes de uma redução em uma abstração, estão relacionados com os termos que possuiam a abstração. Desse modo, definimos como
abaixo o feixo contextual transitivo para o conjunto dos termos, e para o conjunto um pouco mais extenso dos termos marcados. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Inductive} \coqdocvar{contextual\_closure} (\coqdocvar{R}: \coqdocvar{Rel} \coqdocvar{pterm}) : \coqdocvar{Rel} \coqdocvar{pterm} :=\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqdocvar{redex} : \coqdockw{\ensuremath{\forall}} \coqdocvar{t} \coqdocvar{s}, \coqdocvar{R} \coqdocvar{t} \coqdocvar{s} \ensuremath{\rightarrow} \coqdocvar{contextual\_closure} \coqdocvar{R} \coqdocvar{t} \coqdocvar{s}\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqdocvar{app\_left} : \coqdockw{\ensuremath{\forall}} \coqdocvar{t} \coqdocvar{t'} \coqdocvar{u}, \coqdocvar{contextual\_closure} \coqdocvar{R} \coqdocvar{t} \coqdocvar{t'} \ensuremath{\rightarrow} \coqdocvar{term} \coqdocvar{u} \ensuremath{\rightarrow}\coqdoceol
\coqdocindent{15.00em}
\coqdocvar{contextual\_closure} \coqdocvar{R} (\coqdocvar{pterm\_app} \coqdocvar{t} \coqdocvar{u}) (\coqdocvar{pterm\_app} \coqdocvar{t'} \coqdocvar{u})\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqdocvar{app\_right} : \coqdockw{\ensuremath{\forall}} \coqdocvar{t} \coqdocvar{u} \coqdocvar{u'}, \coqdocvar{contextual\_closure} \coqdocvar{R} \coqdocvar{u} \coqdocvar{u'} \ensuremath{\rightarrow} \coqdocvar{term} \coqdocvar{t} \ensuremath{\rightarrow}\coqdoceol
\coqdocindent{15.50em}
\coqdocvar{contextual\_closure} \coqdocvar{R} (\coqdocvar{pterm\_app} \coqdocvar{t} \coqdocvar{u}) (\coqdocvar{pterm\_app} \coqdocvar{t} \coqdocvar{u'})\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqdocvar{abs\_in} : \coqdockw{\ensuremath{\forall}} \coqdocvar{t} \coqdocvar{t'} \coqdocvar{L}, (\coqdockw{\ensuremath{\forall}} \coqdocvar{x}, \coqdocvar{x} \symbol{92}\coqdocvar{notin} \coqdocvar{L} \ensuremath{\rightarrow} \coqdocvar{contextual\_closure} \coqdocvar{R} (\coqdocvar{t}\^{}\coqdocvar{x}) (\coqdocvar{t'}\^{}\coqdocvar{x})) \ensuremath{\rightarrow}\coqdoceol
\coqdocindent{15.50em}
\coqdocvar{contextual\_closure} \coqdocvar{R} (\coqdocvar{pterm\_abs} \coqdocvar{t}) (\coqdocvar{pterm\_abs} \coqdocvar{t'}).\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Inductive} \coqdocvar{lcontextual\_closure} (\coqdocvar{R}: \coqdocvar{Rel} \coqdocvar{pterm}) : \coqdocvar{Rel} \coqdocvar{pterm} :=\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqdocvar{lredex} : \coqdockw{\ensuremath{\forall}} \coqdocvar{t} \coqdocvar{s}, \coqdocvar{R} \coqdocvar{t} \coqdocvar{s} \ensuremath{\rightarrow} \coqdocvar{lcontextual\_closure} \coqdocvar{R} \coqdocvar{t} \coqdocvar{s}\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqdocvar{lapp\_left} : \coqdockw{\ensuremath{\forall}} \coqdocvar{t} \coqdocvar{t'} \coqdocvar{u}, \coqdocvar{lcontextual\_closure} \coqdocvar{R} \coqdocvar{t} \coqdocvar{t'} \ensuremath{\rightarrow} \coqdocvar{lterm} \coqdocvar{u} \ensuremath{\rightarrow}\coqdoceol
\coqdocindent{15.00em}
\coqdocvar{lcontextual\_closure} \coqdocvar{R} (\coqdocvar{pterm\_app} \coqdocvar{t} \coqdocvar{u}) (\coqdocvar{pterm\_app} \coqdocvar{t'} \coqdocvar{u})\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqdocvar{lapp\_right} : \coqdockw{\ensuremath{\forall}} \coqdocvar{t} \coqdocvar{u} \coqdocvar{u'}, \coqdocvar{lcontextual\_closure} \coqdocvar{R} \coqdocvar{u} \coqdocvar{u'} \ensuremath{\rightarrow} \coqdocvar{lterm} \coqdocvar{t} \ensuremath{\rightarrow}\coqdoceol
\coqdocindent{15.50em}
\coqdocvar{lcontextual\_closure} \coqdocvar{R} (\coqdocvar{pterm\_app} \coqdocvar{t} \coqdocvar{u}) (\coqdocvar{pterm\_app} \coqdocvar{t} \coqdocvar{u'})\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqdocvar{labs\_in} : \coqdockw{\ensuremath{\forall}} \coqdocvar{t} \coqdocvar{t'} \coqdocvar{L}, (\coqdockw{\ensuremath{\forall}} \coqdocvar{x}, \coqdocvar{x} \symbol{92}\coqdocvar{notin} \coqdocvar{L} \ensuremath{\rightarrow} \coqdocvar{contextual\_closure} \coqdocvar{R} (\coqdocvar{t}\^{}\coqdocvar{x}) (\coqdocvar{t'}\^{}\coqdocvar{x})) \ensuremath{\rightarrow}\coqdoceol
\coqdocindent{15.50em}
\coqdocvar{lcontextual\_closure} \coqdocvar{R} (\coqdocvar{pterm\_abs} \coqdocvar{t}) (\coqdocvar{pterm\_abs} \coqdocvar{t'})\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqdocvar{l\_abs\_in} : \coqdockw{\ensuremath{\forall}} \coqdocvar{t} \coqdocvar{t'} \coqdocvar{L}, (\coqdockw{\ensuremath{\forall}} \coqdocvar{x}, \coqdocvar{x} \symbol{92}\coqdocvar{notin} \coqdocvar{L} \ensuremath{\rightarrow} \coqdocvar{lcontextual\_closure} \coqdocvar{R} (\coqdocvar{t}\^{}\coqdocvar{x}) (\coqdocvar{t'}\^{}\coqdocvar{x})) \ensuremath{\rightarrow}\coqdoceol
\coqdocindent{15.50em}
\coqdocvar{lcontextual\_closure} \coqdocvar{R} (\coqdocvar{pterm\_labs} \coqdocvar{t}) (\coqdocvar{pterm\_labs} \coqdocvar{t'}).\coqdoceol
\coqdocemptyline
\end{coqdoccode}
De outra forma, também é necessário definir a enésima beta redução. A enésima beta redução consiste na aplicação de n beta reduções
em um termo. Para definir esta operação para a máquina, precisamos de uma definição auxiliar de aplicação transitiva em um determinado termo,
por meio do conceito de relação. Basicamente precisamos fazer com que a máquina percorra recursivamente um termo, dentre os seus diversos pré-termos,
até encontrar todas as beta reduções que fazem um termo a, chegar à um termo b, após n beta reduções. Os casos base são onde existe apenas uma
variável e ela reduz a ela mesma, e uma redução específica de a para b. Abaixo temos duas definições possíveis para essa propriedade, e uma prova
de sua equivalência. \begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Inductive} \coqdocvar{refltrans} (\coqdoctac{red}: \coqdocvar{Rel} \coqdocvar{pterm}) : \coqdocvar{Rel} \coqdocvar{pterm} :=\coqdoceol
\coqdocnoindent
\ensuremath{|} \coqdocvar{reflex}: \coqdockw{\ensuremath{\forall}} \coqdocvar{a}, \coqdocvar{refltrans} \coqdoctac{red} \coqdocvar{a} \coqdocvar{a}\coqdoceol
\coqdocnoindent
\ensuremath{|} \coqdocvar{atleast1}: \coqdockw{\ensuremath{\forall}} \coqdocvar{a} \coqdocvar{b}, \coqdoctac{red} \coqdocvar{a} \coqdocvar{b} \ensuremath{\rightarrow} \coqdocvar{refltrans} \coqdoctac{red} \coqdocvar{a} \coqdocvar{b}\coqdoceol
\coqdocnoindent
\ensuremath{|} \coqdocvar{rtrans}: \coqdockw{\ensuremath{\forall}} \coqdocvar{a} \coqdocvar{b} \coqdocvar{c}, \coqdocvar{refltrans} \coqdoctac{red} \coqdocvar{a} \coqdocvar{b} \ensuremath{\rightarrow} \coqdocvar{refltrans} \coqdoctac{red} \coqdocvar{b} \coqdocvar{c} \ensuremath{\rightarrow} \coqdocvar{refltrans} \coqdoctac{red} \coqdocvar{a} \coqdocvar{c}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Inductive} \coqdocvar{refltrans'} (\coqdoctac{red}: \coqdocvar{Rel} \coqdocvar{pterm}) : \coqdocvar{Rel} \coqdocvar{pterm} :=\coqdoceol
\coqdocnoindent
\ensuremath{|} \coqdocvar{refl}: \coqdockw{\ensuremath{\forall}} \coqdocvar{a}, \coqdocvar{refltrans'} \coqdoctac{red} \coqdocvar{a} \coqdocvar{a}\coqdoceol
\coqdocnoindent
\ensuremath{|} \coqdocvar{rtrans'}: \coqdockw{\ensuremath{\forall}} \coqdocvar{a} \coqdocvar{b} \coqdocvar{c}, \coqdoctac{red} \coqdocvar{a} \coqdocvar{b} \ensuremath{\rightarrow} \coqdocvar{refltrans'} \coqdoctac{red} \coqdocvar{b} \coqdocvar{c} \ensuremath{\rightarrow} \coqdocvar{refltrans'} \coqdoctac{red} \coqdocvar{a} \coqdocvar{c}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdocvar{refltrans\_equiv}: \coqdockw{\ensuremath{\forall}} (\coqdocvar{R}: \coqdocvar{Rel} \coqdocvar{pterm}) (\coqdocvar{a} \coqdocvar{b}: \coqdocvar{pterm}), \coqdocvar{refltrans} \coqdocvar{R} \coqdocvar{a} \coqdocvar{b} \ensuremath{\leftrightarrow} \coqdocvar{refltrans'} \coqdocvar{R} \coqdocvar{a} \coqdocvar{b}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
Assim podemos definir as operações de beta redução, e da enésima beta redução. rule\_b se refere à definição de uma relação
onde um redex é substituiído pela termo resultante da substituição de de todos os index's ligados de um termo qualquer t, por uma variável
u. Na prática, esta é a definição de beta redução, quando esta é posta em conjunto com o feixo contextual transitivo, como visto na definição
do símbolo de beta redução para a máquina: ``-->B''. A operação da enésima beta redução é feita por meio da aplicação sucessiva e recursiva da
operação da beta redução, por meio da regra refltrans, explicada mais acima.\begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Inductive} \coqdocvar{rule\_b} : \coqdocvar{Rel} \coqdocvar{pterm}  :=\coqdoceol
\coqdocindent{1.00em}
\coqdocvar{reg\_rule\_b} : \coqdockw{\ensuremath{\forall}} (\coqdocvar{t} \coqdocvar{u}:\coqdocvar{pterm}), \coqdocvar{body} \coqdocvar{t} \ensuremath{\rightarrow} \coqdocvar{term} \coqdocvar{u} \ensuremath{\rightarrow}\coqdoceol
\coqdocindent{2.00em}
\coqdocvar{rule\_b} (\coqdocvar{pterm\_app}(\coqdocvar{pterm\_abs} \coqdocvar{t}) \coqdocvar{u}) (\coqdocvar{t} \^{}\^{} \coqdocvar{u}).\coqdoceol
\coqdocnoindent
\coqdockw{Notation} "t -->B u" := (\coqdocvar{contextual\_closure} \coqdocvar{rule\_b} \coqdocvar{t} \coqdocvar{u}) (\coqdoctac{at} \coqdockw{level} 60).\coqdoceol
\coqdocnoindent
\coqdockw{Notation} "t -->>B u" := (\coqdocvar{refltrans} (\coqdocvar{contextual\_closure} \coqdocvar{rule\_b}) \coqdocvar{t} \coqdocvar{u}) (\coqdoctac{at} \coqdockw{level} 60).\coqdoceol
\coqdocemptyline
\end{coqdoccode}
O mesmo deve ser definido para o conjunto dos termos marcados. Neste caso, precisamos tomar o cuidado de diferenciar as abstrações das
abstrações marcadas, e tratar cada um dos casos, apesar de sabermos serem análogos, a máquina não o sabe.\begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Inductive} \coqdocvar{rule\_lb} : \coqdocvar{Rel} \coqdocvar{pterm}  :=\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqdocvar{reg\_rule\_bb} : \coqdockw{\ensuremath{\forall}} (\coqdocvar{t} \coqdocvar{u}:\coqdocvar{pterm}), \coqdocvar{body} \coqdocvar{t} \ensuremath{\rightarrow} \coqdocvar{term} \coqdocvar{u} \ensuremath{\rightarrow}\coqdoceol
\coqdocindent{2.00em}
\coqdocvar{rule\_lb} (\coqdocvar{pterm\_app}(\coqdocvar{pterm\_abs} \coqdocvar{t}) \coqdocvar{u}) (\coqdocvar{t} \^{}\^{} \coqdocvar{u})\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqdocvar{reg\_rule\_lb} : \coqdockw{\ensuremath{\forall}} (\coqdocvar{t} \coqdocvar{u}:\coqdocvar{pterm}),\coqdoceol
\coqdocindent{2.00em}
\coqdocvar{body} \coqdocvar{t} \ensuremath{\rightarrow} \coqdocvar{term} \coqdocvar{u} \ensuremath{\rightarrow}\coqdoceol
\coqdocindent{2.00em}
\coqdocvar{rule\_lb} (\coqdocvar{pterm\_app}(\coqdocvar{pterm\_labs} \coqdocvar{t}) \coqdocvar{u}) (\coqdocvar{t} \^{}\^{} \coqdocvar{u}).\coqdoceol
\coqdocnoindent
\coqdockw{Notation} "t -->lB u" := (\coqdocvar{lcontextual\_closure} \coqdocvar{rule\_lb} \coqdocvar{t} \coqdocvar{u}) (\coqdoctac{at} \coqdockw{level} 60).\coqdoceol
\coqdocnoindent
\coqdockw{Notation} "t -->>lB u" := (\coqdocvar{refltrans} (\coqdocvar{lcontextual\_closure} \coqdocvar{rule\_lb}) \coqdocvar{t} \coqdocvar{u}) (\coqdoctac{at} \coqdockw{level} 60).\coqdoceol
\coqdocemptyline
\end{coqdoccode}
\section{Prova da confluência}



\subsection{O que é confluência}



 A confluência no cálculo lambda se define como: Dados dois termos iniciais provenientes de um único termo,
a partir de qualquer conjunto de reduções beta (duas bifurcações quaisquer na árvore de reduções)
 é sempre possível chegar ao mesmo termo resultante (considerando a alfa equivalência). 
Assim, esperamos provar que o cálculo lambda é confluente. Tal característica (confluência) 
permite dizer que o cálculo lambda é determinístico, sendo possível sempre dadas condições iniciais
prever um determinado resultado, ao operar as operações corretas (neste caso, reduções). 

\subsection{Operações necessárias para a prova da confluência}



 Já definimos os termos marcados, por meio da criação de uma ``marca'' em determinados redex's. Um
redex é toda abstração que é base para uma determinada aplicação definida em um determinado termo. Dessa forma, é
necessário definir algumas operações que possam trabalhar com os termos marcados, permitindo que estas marcas
sejam tanto colocadas, quanto retiradas. Geralmente as marcas são criadas na própria definição de uma determinada prova
para então, serem retiradas depois, comparando um termo marcado à um termo não marcado, após uma determinada
sequência de operações do $\lambda$-cálculo, permitindo assim provar determinada hipótese, pois com a marca
é possível acompanhar a o estado de um determinado redex após sucessivas operações. 

 Para isso, uma das operações definidas é a operação de apagamento (erase) de marcas, ou melhor,
a operação de apagar. A operação de apagar consiste em, quando da sua aplicação em um termo, apagar
todas as suas (se houverem) marcas, mas preservando a sua estrutura (sem reduzir os redex's). Essa operação
foi definida recursivamente como se segue abaixo, sendo propagada para dentro de cada termo, com atenção
especial à abstração marcada, que transforma-se em abstração, e mantém a propagação do erase. Assim, 
após a aplicação da operação, um termo marcado se tornará um termo sem marcas, e um termo sem marcas não
sofrerá nenhuma alteração.\begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Fixpoint} \coqdocvar{erase} (\coqdocvar{t}:\coqdocvar{pterm}) : \coqdocvar{pterm} :=\coqdoceol
\coqdocindent{1.00em}
\coqdockw{match} \coqdocvar{t} \coqdockw{with}\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqdocvar{pterm\_app} \coqdocvar{t1} \coqdocvar{t2} \ensuremath{\Rightarrow} \coqdocvar{pterm\_app} (\coqdocvar{erase} \coqdocvar{t1}) (\coqdocvar{erase} \coqdocvar{t2})\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqdocvar{pterm\_abs} \coqdocvar{t1} \ensuremath{\Rightarrow} \coqdocvar{pterm\_abs} (\coqdocvar{erase} \coqdocvar{t1})\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqdocvar{pterm\_labs} \coqdocvar{t1} \ensuremath{\Rightarrow} \coqdocvar{pterm\_abs} (\coqdocvar{erase} \coqdocvar{t1})\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqdocvar{\_} \ensuremath{\Rightarrow} \coqdocvar{t}\coqdoceol
\coqdocindent{1.00em}
\coqdockw{end}.\coqdoceol
\coqdocemptyline
\coqdocemptyline
\coqdocemptyline
\end{coqdoccode}
Dessa forma, também é necessária a definição da função phi. A função phi também trabalha
com marcas, assim como o erase, no entanto possui um funcionamento um pouco distinto. A função phi
possui o papel de, ao ser aplicada em um termo, reduzir todos os redex's marcados (abstrações
com marcas com um determinado termo sendo aplicado). Dessa forma, após a aplicação da operação phi
um termo marcado torna-se um termo sem marcas, porém difere estruturalmente do seu estado anterior,
pelo fato de agora possuir os antigos redexs marcados reduzidos. Perceba que um termo sem marcas, ao
receber a aplicação de phi permanece inalterado, por definição. Definimos a operação como se segue logo
abaixo, recursivamente, a operação phi é propaga pelo termo que sofre a aplicação, reduzindo os redex's
marcados, o encontrar uma aplicação onde o termo mais à esquerda é uma abstração marcada.\begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Fixpoint} \coqdocvar{phi} (\coqdocvar{t}:\coqdocvar{pterm}) : \coqdocvar{pterm} :=\coqdoceol
\coqdocindent{1.00em}
\coqdockw{match} \coqdocvar{t} \coqdockw{with}\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqdocvar{pterm\_app} \coqdocvar{t1} \coqdocvar{t2} \ensuremath{\Rightarrow} \coqdockw{match} \coqdocvar{t1} \coqdockw{with}\coqdoceol
\coqdocindent{11.00em}
\ensuremath{|} \coqdocvar{pterm\_labs} \coqdocvar{t1'} \ensuremath{\Rightarrow} (\coqdocvar{phi} \coqdocvar{t1'}) \^{}\^{} (\coqdocvar{phi} \coqdocvar{t2})\coqdoceol
\coqdocindent{11.00em}
\ensuremath{|} \coqdocvar{\_} \ensuremath{\Rightarrow} \coqdocvar{pterm\_app} (\coqdocvar{phi} \coqdocvar{t1}) (\coqdocvar{phi} \coqdocvar{t2})\coqdoceol
\coqdocindent{11.00em}
\coqdockw{end}\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqdocvar{pterm\_abs} \coqdocvar{t1} \ensuremath{\Rightarrow} \coqdocvar{pterm\_abs} (\coqdocvar{phi} \coqdocvar{t1})\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqdocvar{pterm\_labs} \coqdocvar{t1} \ensuremath{\Rightarrow} \coqdocvar{pterm\_labs} (\coqdocvar{phi} \coqdocvar{t1})\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqdocvar{\_} \ensuremath{\Rightarrow} \coqdocvar{t}\coqdoceol
\coqdocindent{1.00em}
\coqdockw{end}.\coqdoceol
\coqdocemptyline
\coqdocemptyline
\coqdocemptyline
\end{coqdoccode}
Com isso, podemos provar, por exemplo, que um termo marcado torna-se um termo após a aplicação da operação phi. A definição
deste lema está como abaixo, e não é tão complexo realizar a sua prova no coq.\begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdocvar{phi\_term}: \coqdockw{\ensuremath{\forall}} \coqdocvar{t}, \coqdocvar{lterm} \coqdocvar{t} \ensuremath{\rightarrow} \coqdocvar{term} (\coqdocvar{phi} \coqdocvar{t}).\coqdoceol
\coqdocemptyline
\coqdocemptyline
\coqdocemptyline
\coqdocemptyline
\coqdocemptyline
\coqdocemptyline
\coqdocemptyline
\coqdocemptyline
\coqdocemptyline
\coqdocemptyline
\coqdocemptyline
\coqdocemptyline
\coqdocemptyline
\end{coqdoccode}
Na prova de barendregt para a confluência do cálculo lambda também é muito importante provar a propriedade de que, se um termo M reduz para um termo N, então o resultado da
 aplicação da função phi em M, também reduz para o resultado da aplicação da função phi no termo N. A difinição deste lema está logo abaixo.\begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdocvar{phi\_prop}: \coqdockw{\ensuremath{\forall}} \coqdocvar{M} \coqdocvar{N} : \coqdocvar{pterm}, \coqdocvar{lterm} \coqdocvar{M} \ensuremath{\rightarrow} \coqdocvar{lterm} \coqdocvar{N} \ensuremath{\rightarrow} (\coqdocvar{M} -->>\coqdocvar{lB} \coqdocvar{N}) \ensuremath{\rightarrow} (\coqdocvar{phi} \coqdocvar{M}) -->>\coqdocvar{B} (\coqdocvar{phi} \coqdocvar{N}).\coqdoceol
\coqdocemptyline
\coqdocemptyline
\coqdocemptyline
\coqdocemptyline
\end{coqdoccode}
Também possuímos outra propriedade, que será muito importante para a prova da confluência do cálculo lambda. Esta se refere ao 
fato de que se M reduz para N em n passos, sendo M e N termos pertencentes ao conjunto dos termos marcados, então o resultado de aplicar a função
de apagar marcas (erase) em M reduz ao resultado da aplicação da operação de apagar marcas em N. A definição para este lema está logo abaixo em 
duas possíveis formas. Até o momento, não conseguimos completar nenhuma das duas provas ainda no coq.\begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdocvar{erase\_prop1} : \coqdockw{\ensuremath{\forall}} \coqdocvar{M} \coqdocvar{N}: \coqdocvar{pterm}, \coqdocvar{term} \coqdocvar{M} \ensuremath{\rightarrow} \coqdocvar{term} \coqdocvar{N} \ensuremath{\rightarrow} (\coqdocvar{M} -->\coqdocvar{B} \coqdocvar{N}) \ensuremath{\rightarrow} \coqdockw{\ensuremath{\forall}} \coqdocvar{M'} \coqdocvar{N'}, (\coqdocvar{erase} \coqdocvar{M'} = \coqdocvar{M}) \ensuremath{\land} (\coqdocvar{erase} \coqdocvar{N'} = \coqdocvar{N}) \ensuremath{\rightarrow}  (\coqdocvar{M'} -->\coqdocvar{lB} \coqdocvar{N'}).\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdocvar{erase\_prop} : \coqdockw{\ensuremath{\forall}} \coqdocvar{M} \coqdocvar{N} \coqdocvar{M'} \coqdocvar{N'}: \coqdocvar{pterm}, \coqdocvar{term} \coqdocvar{M} \ensuremath{\rightarrow} \coqdocvar{term} \coqdocvar{N} \ensuremath{\rightarrow} (\coqdocvar{M} -->>\coqdocvar{B} \coqdocvar{N}) \ensuremath{\rightarrow} \coqdocvar{erase} \coqdocvar{M'} = \coqdocvar{M} \ensuremath{\rightarrow} \coqdocvar{erase} \coqdocvar{N'} = \coqdocvar{N} \ensuremath{\rightarrow}  (\coqdocvar{M'} -->>\coqdocvar{lB} \coqdocvar{N'}).\coqdoceol
\coqdocemptyline
\coqdocemptyline
\coqdocemptyline
\coqdocemptyline
\end{coqdoccode}
Assim, também precisamos provar que dado um mesmo termo t, se t1 é o termo resultante da aplicação da função de apagar marcas
em t, e t2 o resultado da aplicação da função phi em t, então t1 reduz em n passos para t2. Essa definição vai ser um artifício importante
na prova do strip-lemma, ao seguir a estratégia de barendregt. A definição se encontra logo abaixo, mas ainda não conseguimos a formalizar
em coq.\begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdocvar{erase\_phi}: \coqdockw{\ensuremath{\forall}} \coqdocvar{t} \coqdocvar{t1} \coqdocvar{t2}, \coqdocvar{erase}(\coqdocvar{t}) = \coqdocvar{t1} \ensuremath{\rightarrow} \coqdocvar{phi}(\coqdocvar{t}) = \coqdocvar{t2} \ensuremath{\rightarrow} \coqdocvar{t1} -->>\coqdocvar{B} \coqdocvar{t2}.\coqdoceol
\coqdocemptyline
\coqdocemptyline
\coqdocemptyline
\coqdocemptyline
\coqdocemptyline
\end{coqdoccode}
\section{O strip\_lemma}



 O strip\_lemma é muito importante para a prova da confluência do cálculo lambda, utilizando
a abordagem de Barendregt (citar). O strip\_lemma prova a propriedade de que: Se um termo reduz em um
passo para t1, e também reduz em n passos para t2, então existe um t3 tal que t1 reduz em n passos para t3
e t2 reduz em n passos para t3. 

 Perceba que essa propriedade ainda não prova a nossa definição de confluência, mas está um passo
atrá de tal prova. Ao provar o strip\_lemma e algumas outras propriedades, a prova da confluência do cálculo
lamba é direta. De outra forma, podemos dizer que a prova da confluência no cálculo lambda é uma 
generalização do strip\_lemma. Aida não conseguimos fechar a prova formal do strip\_lemma, mas iremos
apresentar logo abaixo os nossos avanços e apresentar quais os próximo passos que devemos seguir.

\subsection{formalização da prova do strip\_lemma}



 Para realizar a prova do strip\_lemma iremos considerar os termos t, t1 e t2. Porém, para isso, iremos
considerar que o termo t possui em sua composição o seguinte redex: pterm\_app (pterm\_labs Q) P, e apenas
iremos levar em conta este redex marcado para construir as nossas operações. Ou seja, o termo deverá conter apenas
um redex marcado, para podermos acompanhar o seu estado ao longo das operações de prova que serão realizadas.
Dessa forma devemos considerar o seguinte: t1 é o termo obtido ao aplicar uma beta redução marcada em t, 
e reduzir especificamente o redex marcado apresentado. Nesse caso, portanto, aplicando phi(t) temos t1. Ou seja:

 $ phi(t) = t1 $ 

 Com isso, podemos dizer que existe um termo t' cuja erase(t) = t', e t' ->B t1. Assim
podemos reduzir t' para t2 via n reduções beta, e provar que t1 tabém reduz para t2 via n beta reduções. O que está sendo 
realizado neste caso é a manutenção de um redex marcado, após n beta reduções quaisquer, que não ocorrem no redex marcado. 
Em seguida o erase e a função phi são utilizados para demonstrar que os termos convergem em t2. Como esses termos são quaisquer
e a única característica com a qual estamos trabalhando é a marca, então a prova pode ser generalizada para qualquer caso.

 Exemplificando um pouco melhor, uma espécie de contador, como o abaixo poderia ser utilizado para se certificar de que
o termo que está sendo trabalhado é um termo com apenas um redex marcado. Este é um dos caminhos de prova com o qual estamos
trabalhando no projeto.\begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Fixpoint} \coqdocvar{lredex\_count} (\coqdocvar{t}:\coqdocvar{pterm}):(\coqdocvar{nat}) :=\coqdoceol
\coqdocnoindent
\coqdockw{match} \coqdocvar{t} \coqdockw{with}\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqdocvar{pterm\_bvar} \coqdocvar{i} \ensuremath{\Rightarrow} 0\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqdocvar{pterm\_fvar} \coqdocvar{x} \ensuremath{\Rightarrow} 0\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqdocvar{pterm\_app} \coqdocvar{t1} \coqdocvar{t2} \ensuremath{\Rightarrow} (\coqdocvar{lredex\_count} \coqdocvar{t1}) + (\coqdocvar{lredex\_count} \coqdocvar{t2})\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqdocvar{pterm\_abs} \coqdocvar{t1}    \ensuremath{\Rightarrow} (\coqdocvar{lredex\_count} \coqdocvar{t1})\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqdocvar{pterm\_labs} \coqdocvar{t1}   \ensuremath{\Rightarrow} 1 + (\coqdocvar{lredex\_count} \coqdocvar{t1})\coqdoceol
\coqdocnoindent
\coqdockw{end}.\coqdoceol
\coqdocemptyline
\coqdocemptyline
\coqdocemptyline
\end{coqdoccode}
A prova será realizada por meio da indução na estrutura da beta redução de t para t1. Assim chegamos a quatro
casos. Estes casos são relativos à própria estrutura da beta redução de t para t1. Ao provar os passos anteriores, 
a prova se completa por indução para o caso geral. No entanto, a definição atual do strip\_lemma
está muito generalizada, não havendo, por exemplo, um termo marcado definido com apenas uma marca que possa ser acompanhada
durante a prova. Nesse caso, vamos utilizar a notação de nomes locais sem marcas e o trabalho de \symbol{92}cite\{chatgerout\} (citar certo)
para nos ajudar a completar a prova mesmo de maneira generalizada, mas também apresentamos opções ilustrativas mais abaixo.   

 Dado esse contexto, dois caminhos podem ser seguidos: No primeiro, a definição do teorema poderia ser refeita, de uma
maneira menos generalizada, abarcando as marcas e utilizando alguma ideia semelhante à apresentada na função lredex\_count. O segundo 
caminho, seria a construção de diversos lemas auxiliares que permitiriam com que o teorema geral pudesse ser provado. Na realidade
o sucesso em realizar esta prova provavelmente depende um caminho intermediário entre essas duas opções. Atualmente, seguimos o
caminho da criação de diversos lemas auxiliares, como vamos explanar mais abaixo. Mas, em vistas de ilustrar uma opção de prova 
diferente, apresentamos abaixo uma definição menos genralizada para o teorema como exemplo: 

 $ Theorem strip_lemma: forall  lterm_one t', term t t1 t2, erase(t') = t -> phi(t') = t1 ->
t -->B t1 -> t -->>B t2 -> exists t3, t1 -->>B t3 /\ t2 -->>B t3. $ 

 Onde lterm\_one é a definição de um termo marcado qualquer, que possui apenas uma marca. t' é um termo com as mesmas propriedades
estruturais de t, exceto pelo redex marcado, sendo isto definido pela igualdade $ erase(t') = t $ e t1 é o termo cuja estrutura
reduz de t com uma beta redução no redex marcado, o que é nesse caso definido pela igualdade $ phi(t') = t1 $. Assim, como t é um
termo qualquer com ao menos um redex, a prova é suficiente para o strip\_lemma. Lembramos que essa pode não ser a melhor abordagem para
um assistente de provas, mas exemplifica muito bem o que \symbol{92}cite\{barendregt\} (melhorar citação) fez em sua prova, podendo ser tomado como base para o sucesso
na formalização dessa prova. 

\subsubsection{Prova formal do strip\_lemma, com a definição generalizada}

\begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Theorem} \coqdocvar{strip\_lemma}: \coqdockw{\ensuremath{\forall}}  \coqdocvar{t} \coqdocvar{t1} \coqdocvar{t2}, \coqdocvar{t} -->\coqdocvar{B} \coqdocvar{t1} \ensuremath{\rightarrow} \coqdocvar{t} -->>\coqdocvar{B} \coqdocvar{t2} \ensuremath{\rightarrow} \coqdoctac{\ensuremath{\exists}} \coqdocvar{t3}, \coqdocvar{t1} -->>\coqdocvar{B} \coqdocvar{t3} \ensuremath{\land} \coqdocvar{t2} -->>\coqdocvar{B} \coqdocvar{t3}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{intros} \coqdocvar{t} \coqdocvar{t1} \coqdocvar{t2} \coqdocvar{H1} \coqdocvar{H2}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
Iniciamos com a indução na estrutura da beta redução em um passo (de t para t1 na notação utilizada):\begin{coqdoccode}
\coqdocemptyline
\coqdocindent{1.00em}
\coqdoctac{induction} \coqdocvar{H1}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
A prova se divide em 4 ramos, e podemos perceber que nenhum deles é um caso simples. Os detalhes das operações de prova mais
abaixo são irrelevantes para os objetivos deste relatório, e por isso não serão apresentados. Incentivamos que as operações sejam
copiadas, caso haja o interesse em continuar a prova deste ponto de partida.\begin{coqdoccode}
\coqdocemptyline
\coqdocindent{1.00em}
- \coqdoctac{inversion} \coqdocvar{H}; \coqdoctac{subst}.\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{apply} \coqdocvar{refltrans\_equiv} \coqdoctac{in} \coqdocvar{H2}.\coqdoceol
\coqdocindent{2.00em}
\coqdocvar{remember} (\coqdocvar{t1} \^{}\^{} \coqdocvar{u}) \coqdockw{as} \coqdocvar{b}.\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{generalize}  \coqdoctac{dependent} \coqdocvar{b}.\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{induction} \coqdocvar{H2}.\coqdoceol
\coqdocindent{2.00em}
+ \coqdoctac{\ensuremath{\exists}} (\coqdocvar{t1} \^{}\^{} \coqdocvar{u}); \coqdoctac{split}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{apply} \coqdocvar{reflex}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdoctac{apply} \coqdocvar{atleast1}.\coqdoceol
\coqdocindent{4.00em}
\coqdoctac{apply} \coqdocvar{redex}.\coqdoceol
\coqdocindent{4.00em}
\coqdoctac{assumption}.\coqdoceol
\coqdocindent{2.00em}
+ \coqdoctac{inversion} \coqdocvar{H}; \coqdoctac{subst}.\coqdoceol
\coqdocindent{3.00em}
\coqdoctac{rewrite} \ensuremath{\leftarrow} \coqdocvar{H3} \coqdoctac{in} \coqdocvar{H}.\coqdoceol
\coqdocindent{3.00em}
\coqdoctac{clear} \coqdocvar{H0} \coqdocvar{H1} \coqdocvar{H3}.\coqdoceol
\coqdocemptyline
\coqdocindent{3.00em}
\coqdoctac{inversion} \coqdocvar{H2}; \coqdoctac{subst}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdocvar{admit}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdocvar{admit}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdocvar{admit}.\coqdoceol
\coqdocindent{2.00em}
+ \coqdoceol
\coqdocindent{3.00em}
\coqdoctac{apply} \coqdocvar{open\_rec\_inj} \coqdoctac{in} \coqdocvar{H3}.\coqdoceol
\coqdocindent{3.00em}
\coqdoctac{destruct} \coqdocvar{H3} \coqdockw{as} [\coqdocvar{Heq1} \coqdocvar{Heq2}]; \coqdoctac{subst}.\coqdoceol
\coqdocindent{3.00em}
\coqdoctac{clear} \coqdocvar{H4} \coqdocvar{H6}.\coqdoceol
\coqdocindent{3.00em}
\coqdoctac{induction} \coqdocvar{H2}.\coqdoceol
\coqdocindent{3.00em}
\ensuremath{\times} \coqdocvar{Admitted}.\coqdoceol
\coqdocemptyline
\coqdocemptyline
\end{coqdoccode}
A definição do lemma erase\_lbeta\_2313 trabalha com a equivalência, dados termos de mesma estrutura porém dois com
marcas e dois sem marcas, da redução destes pares de termos pelas beta reduções marcadas e não marcadas. Essa definição é
necessária para trabalhar com a marca e a acompanhar de modo a ser possível enxergar os estados da estrutura com a qual estamos
trabalhando. \begin{coqdoccode}
\coqdocemptyline
\coqdocindent{2.00em}
\coqdockw{Lemma} \coqdocvar{erase\_lbeta\_2313}: \coqdockw{\ensuremath{\forall}} \coqdocvar{t1} \coqdocvar{t2}, \coqdocvar{t1} -->>\coqdocvar{B} \coqdocvar{t2} \ensuremath{\rightarrow} \coqdockw{\ensuremath{\forall}} \coqdocvar{t1'} \coqdocvar{t2'}, \coqdocvar{erase}(\coqdocvar{t1'}) = \coqdocvar{t1} \ensuremath{\land} \coqdocvar{erase}(\coqdocvar{t2'}) = \coqdocvar{t2} \ensuremath{\rightarrow} \coqdocvar{t1'} -->>\coqdocvar{lB} \coqdocvar{t2'}.\coqdoceol
\coqdocindent{2.00em}
\coqdockw{Proof}.\coqdoceol
\coqdocindent{3.00em}
\coqdocvar{Admitted}.\coqdoceol
\coqdocemptyline
\coqdocindent{2.00em}
\coqdoctac{assert} (\coqdocvar{H'}: \coqdocvar{pterm\_app} (\coqdocvar{pterm\_labs} \coqdocvar{t1}) \coqdocvar{u} -->>\coqdocvar{B} \coqdocvar{t2}).\coqdoceol
\coqdocindent{2.00em}
\{\coqdoceol
\coqdocindent{3.00em}
\coqdoctac{apply} \coqdocvar{erase\_lbeta\_2313}.\coqdoceol
\coqdocindent{2.00em}
\}\coqdoceol
\coqdocindent{2.50em}
\coqdoctac{in} \coqdocvar{H2} \coqdockw{with} (\coqdocvar{pterm\_app} (\coqdocvar{pterm\_labs} \coqdocvar{t1}) \coqdocvar{u}) \coqdocvar{\_}.\coqdoceol
\coqdocemptyline
\coqdocemptyline
\coqdocindent{1.00em}
\coqdoctac{assert} (\coqdocvar{H2'} := \coqdocvar{H2}).\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{assert} (\coqdockw{\ensuremath{\forall}} \coqdocvar{t'}, \coqdocvar{erase}(\coqdocvar{t'}) = \coqdocvar{t} \ensuremath{\rightarrow} \coqdockw{\ensuremath{\forall}} \coqdocvar{t2'}, \coqdocvar{erase}(\coqdocvar{t2'}) = \coqdocvar{t2} \ensuremath{\rightarrow} \coqdocvar{t'} -->>\coqdocvar{lB} \coqdocvar{t2'}).\coqdoceol
\coqdocindent{1.00em}
\{\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{apply} \coqdocvar{erase\_lbeta}; \coqdoctac{assumption}.\coqdoceol
\coqdocindent{1.00em}
\}\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{inversion} \coqdocvar{H1}; \coqdoctac{subst}.\coqdoceol
\coqdocindent{1.00em}
- \coqdoctac{inversion} \coqdocvar{H0}; \coqdoctac{subst}.\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{assert} (\coqdocvar{erase} (\coqdocvar{pterm\_app} (\coqdocvar{pterm\_labs} \coqdocvar{t0}) \coqdocvar{u}) = \coqdocvar{pterm\_app} (\coqdocvar{pterm\_abs} \coqdocvar{t0}) \coqdocvar{u} \ensuremath{\rightarrow} \coqdockw{\ensuremath{\forall}} \coqdocvar{t2'}, \coqdocvar{erase} \coqdocvar{t2'} = \coqdocvar{t2} \ensuremath{\rightarrow} \coqdocvar{pterm\_app} (\coqdocvar{pterm\_labs} \coqdocvar{t0}) \coqdocvar{u} -->>\coqdocvar{lB} \coqdocvar{t2'}).\coqdoceol
\coqdocindent{2.00em}
\{\coqdoceol
\coqdocindent{3.00em}
\coqdoctac{apply} \coqdocvar{H}.\coqdoceol
\coqdocindent{2.00em}
\}\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{clear} \coqdocvar{H}.\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{assert} (\coqdocvar{erase} (\coqdocvar{pterm\_app} (\coqdocvar{pterm\_labs} \coqdocvar{t0}) \coqdocvar{u}) = \coqdocvar{pterm\_app} (\coqdocvar{pterm\_abs} \coqdocvar{t0}) \coqdocvar{u}).\coqdoceol
\coqdocindent{2.00em}
\{\coqdoceol
\coqdocindent{3.00em}
\coqdoctac{simpl}.\coqdoceol
\coqdocindent{3.00em}
\coqdoctac{rewrite} \coqdocvar{body\_erase}.\coqdoceol
\coqdocindent{3.00em}
- \coqdoctac{rewrite} \coqdocvar{term\_erase}.\coqdoceol
\coqdocindent{4.00em}
+ \coqdoctac{reflexivity}.\coqdoceol
\coqdocindent{4.00em}
+ \coqdoctac{assumption}.\coqdoceol
\coqdocindent{3.00em}
- \coqdoctac{assumption}.\coqdoceol
\coqdocindent{2.00em}
\}\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{assert} (\coqdockw{\ensuremath{\forall}} \coqdocvar{t2'} : \coqdocvar{pterm}, \coqdocvar{erase} \coqdocvar{t2'} = \coqdocvar{t2} \ensuremath{\rightarrow} \coqdocvar{pterm\_app} (\coqdocvar{pterm\_labs} \coqdocvar{t0}) \coqdocvar{u} -->>\coqdocvar{lB} \coqdocvar{t2'}).\coqdoceol
\coqdocindent{2.00em}
\{\coqdoceol
\coqdocindent{3.00em}
\coqdoctac{apply} \coqdocvar{H5}.\coqdoceol
\coqdocindent{3.00em}
\coqdoctac{assumption}.\coqdoceol
\coqdocindent{2.00em}
\}\coqdoceol
\coqdocindent{2.00em}
\coqdoctac{clear} \coqdocvar{H} \coqdocvar{H5}.\coqdoceol
\coqdocindent{2.00em}
\coqdocvar{Admitted}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
